#+TITLE: My Emacs Configuration
#+AUTHOR: Chris Liourtas
#+EMAIL: cliourtas@kracked.tech
#+OPTIONS: num:nil
#+macro: latest-export-date (eval (format-time-string "%F %T %z"))
#+macro: word-count (eval (count-words (point-min) (point-max)))

* Emacs
*Last export {{{latest-export-date}}} with {{{word-count}}} words.*
** Early initialization of Emacs (=early-init.el=)
#+begin_src emacs-lisp :tangle "early-init.el"
  (setq package-enable-at-startup nil)
#+end_src
** The main initialization of Emacs (=init.el=)
*** User Options
All of the user options are defined under the emacs group
=my-emacs=. A group in emacs-lisp is just a way to organize metadata
for Emacs' customization system. By modifying these values via =M-x
customize= the user can easily manipulate My-Emacs' behavior. Things
that can be modified are:
    - Theme-Families.
    - Enabled/Disabled Features.
    - UI (User Interface).
To define the group we use the =defgroup= macro.
#+begin_src emacs-lisp :tangle "init.el"
  (defgroup my-emacs nil
   "User options for my-emacs."
    :group 'emacs
  )
#+end_src
**** Theme Option
#+begin_src emacs-lisp :tangle "init.el"
  (defcustom my-emacs-load-theme-family 'nano
    "Set of themes to load."
    :group 'my-emacs
    :type '(choice :tag "Set of themes to load" :value 'nano
  	 )
  )
#+end_src
**** User Interface Options
***** Dired Order Option
This is better explained in the Dired section.
#+begin_src emacs-lisp :tangle "init.el"
  (defcustom my-emacs-dired-order '(dirs hidden-dirs files hidden-files)
    "The order of which dired displays its items.
  Each element should be one of the following symbols:
  - `dirs` : visible directories
  - `hidden-dirs` : hidden directories (starting with '.')
  - `files` : visible files
  - `hidden-files` : hidden files (starting with '.')"
    :group 'my-emacs
    :type '(repeat
  	  (choice (const dirs)
  		  (const hidden-dirs)
  		  (const files)
  		  (const hidden-files)))
  )
#+end_src
***** Tool-Bar Option
#+begin_src emacs-lisp :tangle "init.el"
  (defcustom my-emacs-tool-bar -1
    "If non-nil, enable `tool-bar-mode`."
    :group 'my-emacs
    :type 'boolean
  )
#+end_src
***** Menu-Bar Option
#+begin_src emacs-lisp :tangle "init.el"
  (defcustom my-emacs-menu-bar -1
    "If non-nil, enable `menu-bar-mode`."
    :group 'my-emacs
    :type 'boolean
  )
#+end_src
***** Scroll-Bar Option
#+begin_src emacs-lisp :tangle "init.el"
  (defcustom my-emacs-scroll-bar -1
    "If non-nil, enable `scroll-bar-mode`."
    :group 'my-emacs
    :type 'boolean
  )
#+end_src
**** Feature Options
***** Vim Scrolling Option
#+begin_src emacs-lisp :tangle "init.el"
  (defcustom my-emacs-vim-scrolling t
    "If non-nil, enable smooth scrolling, like vim."
     :group 'my-emacs
     :type 'boolean
  )
#+end_src
***** Evil Mode Option
#+begin_src emacs-lisp :tangle "init.el"
  (defcustom my-emacs-evil t
      "If non-nil, enable evil mode for vim emulation."
       :group 'my-emacs
       :type 'boolean
  )
#+end_src
***** Rust Language Support
#+begin_src emacs-lisp :tangle "init.el"
  (defcustom my-emacs-rust t
    "If non-nil, enable support for Rust."
    :group 'my-emacs
    :type 'boolean
  )
#+end_src
***** Ocaml Language Support
#+begin_src emacs-lisp :tangle "init.el"
  (defcustom my-emacs-ocaml t
    "If non-nil, enable support for Ocaml."
    :group 'my-emacs
    :type 'boolean
  )
#+end_src
***** Haskell Language Support
#+begin_src emacs-lisp :tangle "init.el"
  (defcustom my-emacs-haskell t
    "If non-nil, enable support for Haskell."
    :group 'my-emacs
    :type 'boolean
  )
#+end_src
***** C/C++ Language Support
#+begin_src emacs-lisp :tangle "init.el"
  (defcustom my-emacs-c-c++ t
    "If non-nil, enable support for C/C++."
    :group 'my-emacs
    :type 'boolean
  )
#+end_src
*** Variables
Directory that contains all of the =use-package= declarations.
#+begin_src emacs-lisp :tangle "init.el"
  (defvar my-emacs-packages-dir
    (concat user-emacs-directory "my-emacs-packages/")
    "Directory that contains all of the `USE-PACKAGE` declarations."
  )
#+end_src
Ordered priority of packages that must be loaded.
#+begin_src emacs-lisp :tangle "init.el"
  (defvar my-emacs-packages-priority
    '("my-emacs-general.el")
    "Basenames or regexps of packages files to load first (ordered)."
  )
#+end_src
*** Package Manager
This emacs configuration uses [[https://github.com/progfolio/elpaca][elpaca]] as its package manager (for
now). I have been thinking of switching to a manual approach but for
now this will do. This will clone elpaca into your =user-emacs-directory= under
the elpaca subdirectory, clone it and finally activate it.
#+begin_src emacs-lisp :tangle "init.el"
  (defvar elpaca-installer-version 0.11)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                                :ref nil :depth 1 :inherit ignore
                                :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                                :build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
         (build (expand-file-name "elpaca/" elpaca-builds-directory))
         (order (cdr elpaca-order))
         (default-directory repo))
    (add-to-list 'load-path (if (file-exists-p build) build repo))
    (unless (file-exists-p repo)
      (make-directory repo t)
      (when (<= emacs-major-version 28) (require 'subr-x))
      (condition-case-unless-debug err
          (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                    ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                    ,@(when-let* ((depth (plist-get order :depth)))
                                                        (list (format "--depth=%d" depth) "--no-single-branch"))
                                                    ,(plist-get order :repo) ,repo))))
                    ((zerop (call-process "git" nil buffer t "checkout"
                                          (or (plist-get order :ref) "--"))))
                    (emacs (concat invocation-directory invocation-name))
                    ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                          "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                    ((require 'elpaca))
                    ((elpaca-generate-autoloads "elpaca" repo)))
              (progn (message "%s" (buffer-string)) (kill-buffer buffer))
            (error "%s" (with-current-buffer buffer (buffer-string))))
        ((error) (warn "%s" err) (delete-directory repo 'recursive))))
    (unless (require 'elpaca-autoloads nil t)
      (require 'elpaca)
      (elpaca-generate-autoloads "elpaca" repo)
      (let ((load-source-file-function nil)) (load "./elpaca-autoloads"))))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))
#+end_src
Then I enable use-package
#+begin_src emacs-lisp :tangle "init.el"
    (elpaca elpaca-use-package
      (elpaca-use-package-mode))
#+end_src

