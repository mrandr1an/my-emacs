#+TITLE: My Emacs Configuration
#+AUTHOR: Chris Liourtas
#+EMAIL: cliourtas@kracked.tech
#+OPTIONS: num:nil
#+macro: latest-export-date (eval (format-time-string "%F %T %z"))
#+macro: word-count (eval (count-words (point-min) (point-max)))

* Emacs
*Last export {{{latest-export-date}}} with {{{word-count}}} words.*
** Early initialization of Emacs (=early-init.el=)
#+begin_src emacs-lisp :tangle "early-init.el"
  (setq package-enable-at-startup nil)
#+end_src
** The main initialization of Emacs (=init.el=)
*** User Options
All of the user options are defined under the emacs group
=my-emacs=. A group in emacs-lisp is just a way to organize metadata
for Emacs' customization system. By modifying these values via =M-x
customize= the user can easily manipulate My-Emacs' behavior. Things
that can be modified are:
    - Theme-Families.
    - Enabled/Disabled Features.
    - UI (User Interface).
To define the group we use the =defgroup= macro.
#+begin_src emacs-lisp :tangle "init.el"
  (defgroup my-emacs nil
   "User options for my-emacs."
    :group 'emacs
  )
#+end_src
**** Theme Option
#+begin_src emacs-lisp :tangle "init.el"
  (defcustom my-emacs-load-theme-family 'nano
    "Set of themes to load."
    :group 'my-emacs
    :type '(choice :tag "Set of themes to load" :value 'nano
  	 )
  )
#+end_src
**** User Interface Options
***** Dired Order Option
This is better explained in the Dired section.
#+begin_src emacs-lisp :tangle "init.el"
  (defcustom my-emacs-dired-order '(dirs hidden-dirs files hidden-files)
    "The order of which dired displays its items.
  Each element should be one of the following symbols:
  - `dirs` : visible directories
  - `hidden-dirs` : hidden directories (starting with '.')
  - `files` : visible files
  - `hidden-files` : hidden files (starting with '.')"
    :group 'my-emacs
    :type '(repeat
  	  (choice (const dirs)
  		  (const hidden-dirs)
  		  (const files)
  		  (const hidden-files)))
  )
#+end_src
***** Tool-Bar Option
#+begin_src emacs-lisp :tangle "init.el"
  (defcustom my-emacs-tool-bar -1
    "If non-nil, enable `tool-bar-mode`."
    :group 'my-emacs
    :type 'boolean
  )
#+end_src
***** Menu-Bar Option
#+begin_src emacs-lisp :tangle "init.el"
  (defcustom my-emacs-menu-bar -1
    "If non-nil, enable `menu-bar-mode`."
    :group 'my-emacs
    :type 'boolean
  )
#+end_src
***** Scroll-Bar Option
#+begin_src emacs-lisp :tangle "init.el"
  (defcustom my-emacs-scroll-bar -1
    "If non-nil, enable `scroll-bar-mode`."
    :group 'my-emacs
    :type 'boolean
  )
#+end_src
**** Feature Options
***** Vim Scrolling Option
#+begin_src emacs-lisp :tangle "init.el"
  (defcustom my-emacs-vim-scrolling t
    "If non-nil, enable smooth scrolling, like vim."
     :group 'my-emacs
     :type 'boolean
  )
#+end_src
***** Evil Mode Option
#+begin_src emacs-lisp :tangle "init.el"
  (defcustom my-emacs-evil t
      "If non-nil, enable evil mode for vim emulation."
       :group 'my-emacs
       :type 'boolean
  )
#+end_src
***** Rust Language Support
#+begin_src emacs-lisp :tangle "init.el"
  (defcustom my-emacs-rust t
    "If non-nil, enable support for Rust."
    :group 'my-emacs
    :type 'boolean
  )
#+end_src
***** Ocaml Language Support
#+begin_src emacs-lisp :tangle "init.el"
  (defcustom my-emacs-ocaml t
    "If non-nil, enable support for Ocaml."
    :group 'my-emacs
    :type 'boolean
  )
#+end_src
***** Haskell Language Support
#+begin_src emacs-lisp :tangle "init.el"
  (defcustom my-emacs-haskell t
    "If non-nil, enable support for Haskell."
    :group 'my-emacs
    :type 'boolean
  )
#+end_src
***** C/C++ Language Support
#+begin_src emacs-lisp :tangle "init.el"
  (defcustom my-emacs-c-c++ t
    "If non-nil, enable support for C/C++."
    :group 'my-emacs
    :type 'boolean
  )
#+end_src
*** Variables
Directory that contains all of the =use-package= declarations.
#+begin_src emacs-lisp :tangle "init.el"
  (defvar my-emacs-packages-dir
    (concat user-emacs-directory "my-emacs-packages/")
    "Directory that contains all of the `USE-PACKAGE` declarations."
  )
#+end_src
Ordered priority of packages that must be loaded.
#+begin_src emacs-lisp :tangle "init.el"
  (defvar my-emacs-packages-priority
    '("my-emacs-general.el")
    "Basenames or regexps of packages files to load first (ordered)."
  )
#+end_src
*** Package Manager
This emacs configuration uses [[https://github.com/progfolio/elpaca][elpaca]] as its package manager (for
now). I have been thinking of switching to a manual approach but for
now this will do. This will clone elpaca into your =user-emacs-directory= under
the elpaca subdirectory, clone it and finally activate it.
#+begin_src emacs-lisp :tangle "init.el"
  (defvar elpaca-installer-version 0.11)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                                :ref nil :depth 1 :inherit ignore
                                :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                                :build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
         (build (expand-file-name "elpaca/" elpaca-builds-directory))
         (order (cdr elpaca-order))
         (default-directory repo))
    (add-to-list 'load-path (if (file-exists-p build) build repo))
    (unless (file-exists-p repo)
      (make-directory repo t)
      (when (<= emacs-major-version 28) (require 'subr-x))
      (condition-case-unless-debug err
          (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                    ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                    ,@(when-let* ((depth (plist-get order :depth)))
                                                        (list (format "--depth=%d" depth) "--no-single-branch"))
                                                    ,(plist-get order :repo) ,repo))))
                    ((zerop (call-process "git" nil buffer t "checkout"
                                          (or (plist-get order :ref) "--"))))
                    (emacs (concat invocation-directory invocation-name))
                    ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                          "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                    ((require 'elpaca))
                    ((elpaca-generate-autoloads "elpaca" repo)))
              (progn (message "%s" (buffer-string)) (kill-buffer buffer))
            (error "%s" (with-current-buffer buffer (buffer-string))))
        ((error) (warn "%s" err) (delete-directory repo 'recursive))))
    (unless (require 'elpaca-autoloads nil t)
      (require 'elpaca)
      (elpaca-generate-autoloads "elpaca" repo)
      (let ((load-source-file-function nil)) (load "./elpaca-autoloads"))))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))
#+end_src
Then I enable use-package
#+begin_src emacs-lisp :tangle "init.el"
    (elpaca elpaca-use-package
      (elpaca-use-package-mode))
#+end_src
I use use-package for declaratively configuring emacs
#+begin_src emacs-lisp :tangle "init.el"
  (use-package emacs
    :ensure nil
    :init
    (add-to-list 'load-path (expand-file-name "core/" user-emacs-directory))
    (add-to-list 'load-path (expand-file-name "my-emacs-packages/" user-emacs-directory))
    :config
    (load "my-emacs-functions")
    (tool-bar-mode my-emacs-tool-bar)
    (menu-bar-mode my-emacs-menu-bar)
    (scroll-bar-mode my-emacs-scroll-bar)
    (my-emacs-vim-scrolling-mode my-emacs-vim-scrolling)
    (my-emacs-load-packages)
  )
#+end_src
** Core Functions (=my-emacs-functions.el=)
This file contains functions that:
  - Have no dependencies.
  - Do not warrant a creation of a library and/or mode.
  - May or not be moved as a library and/or mode later.
*** TODO Vim Scrolling Mode
This is not a mode, its a function. It might be a good idea to make it
a minor mode later, so for now its marked as TODO.
#+begin_src emacs-lisp :tangle "core/my-emacs-functions.el" :mkdirp yes
  (defun my-emacs-vim-scrolling-mode (enable)
    "Enable or disable 'vim-like' smooth scrolling depending on ENABLE."
    (if enable (progn
  	       (setq scroll-step 1)
  	       (setq scroll-margin 1)
  	       (setq scroll-conservatively 9999)))
  )
#+end_src
*** TODO Load Package
Loading packages should be done in a fixed order since packages may depend on each other.
For example =general.el= should be loaded before =magit.el= since the latter depends on the former.
This code may look complicated so a description is warranted:
 1. First define a helper function =my-emacs--priority-match-p=.
   This function simply takes two strings =`FILE`= which is a
   full path to a file and =`PATTERN`= which is a regex string
   or just the file name.
    - If =`FILE`= is equal to =`PATTERN`= return =`TRUE`=
 2. Now define the loader =my-emacs-load-packages=. Declare
   variables:
    - =all= List of absolute paths to every =.el= file inside =my-emacs-packages-dir=.
    - =seen= A hash-table data structure created by =make-hash-table=.
    - =head= The *ORDERED* list of priority files. Initialized by
      looping =my-emacs-packages-priority= and =all=. If a string (file name)
      defined there is not in =seen= yet and matches a string in all its a
      package that needs priority. 
    - =tail= The possibly unordered list of non-prioritized files. Initialized
      by being the rest "seen" files.
    - =files= Concats the =head= and =tail=.
    Now everything is ordered.
 3. Loop through =files=, load everything.
#+begin_src emacs-lisp :tangle "core/my-emacs-functions.el"
  (defun my-emacs--priority-match-p (file pattern)
    (let ((name (file-name-nondirectory file)))
      (or (string= name pattern)
  	(string-match-p pattern name))))

  (defun my-emacs-load-packages (&optional nosort)
    "Load all '.el' files in `MY-EMACS-PACKAGES-DIR` honoring,
  `MY-EMACS-PACKAGES-PRIORITY`.If NOSORT is non-nil, do not sort the
  non-priority tail (raw FS order)."
    (let* ((all (directory-files my-emacs-packages-dir t "\\.el\\'" nosort))
           (seen (make-hash-table :test 'equal))
           (head (cl-loop for pat in my-emacs-packages-priority append
                          (cl-remove-if-not
                           (lambda (f)
                             (and (my-emacs--priority-match-p f pat)
                                  (not (gethash f seen))
                                  (prog1 t (puthash f t seen))))
                           all)))
           (tail (cl-remove-if (lambda (f) (gethash f seen)) all))
           (files (nconc head tail)))
      (dolist (f files)
        (condition-case err
            (load f nil 'nomessage)
          (error
           (message "[my-emacs] Failed to load %s: %s"
                    (file-name-nondirectory f) err))))))
#+end_src
** Libraries
** Packages
*** General
For key-binding management I use [[https://github.com/noctuid/general.el][general]]. It provides many
useful features for defining key-bindings. I mostly take advantage
of the =:general= keyword in use-package that comes with installing it.
Notice the =(elpaca-wait)= after the package declaration.
 - TODO I should probably find a way to use =general-create-definer= and then use it on use-package.
   perhaps create my own =use-package= keyword? This would allow for global usage of an "evil-leader"-like
   key and perhaps further customization for the user.
#+begin_src emacs-lisp :tangle "my-emacs-packages/my-emacs-general.el" :mkdirp yes
  (use-package general
    :ensure (:wait t)
    :demand t
    :config
    (general-auto-unbind-keys)
  )
#+end_src
*** Evil Mode
[[https://github.com/emacs-evil/evil][Evil]] provides a vim-motions emulation layer on top of emacs. This package
should only be loaded if =my-emacs-evil= variable is non-nil.
#+begin_src emacs-lisp :tangle "my-emacs-packages/my-emacs-evil.el" :mkdirp yes
  (use-package evil
    :ensure t
    :after general
    :if my-emacs-evil
    :custom (evil-want-keybinding nil)
    (evil-want-integration t)
    (evil-want-minibuffer t) 
    :config
    (evil-mode)
  )
#+end_src
[[https://github.com/emacs-evil/evil-collection][Evil-collection]] is a collection of evil bindings for the parts of Emacs that
evil does not cover properly by default.
#+begin_src emacs-lisp :tangle "my-emacs-packages/my-emacs-evil.el"
  (use-package evil-collection
    :ensure t
    :after evil
    :config
    (evil-collection-init)
  )
#+end_src
[[https://github.com/redguardtoo/evil-nerd-commenter][Evil-Nerd-Commenter]] is just a quick and fancy way to comment code. It comes
with a few functions (no modes), but I just use =evilnc-comment-or-uncomment-lines=.
#+begin_src emacs-lisp :tangle "my-emacs-packages/my-emacs-evil.el"
  (use-package evil-nerd-commenter
    :ensure t
    :after evil
    :general
    (:keymaps 'evil-visual-state-map
  	    "gcc" 'evilnc-comment-or-uncomment-lines)
    (:keymaps 'evil-normal-state-map
  	    "gcc" 'evilnc-comment-or-uncomment-lines)
  )
#+end_src
[[https://github.com/emacs-evil/evil-surround][Evil-Surround]] is the evil equivelant of [[https://github.com/tpope/vim-surround][surround.vim]].
#+begin_src emacs-lisp :tangle "my-emacs-packages/my-emacs-evil.el"
  (use-package evil-surround
    :ensure t
    :after evil
    :hook evil-mode
  )
#+end_src
[[https://github.com/emacsmirror/undo-fu][Undo-Fu]] provides undo-redo for Emacs.
#+begin_src emacs-lisp :tangle "my-emacs-packages/my-emacs-evil.el"
  (use-package undo-fu
    :ensure t
    :after evil
    :custom
    (evil-undo-system 'undo-fu)
  )
#+end_src
[[https://github.com/gabesoft/evil-mc][Evil-mc]] provides multi-cursor functionallity for emacs-evil.
#+begin_src emacs-lisp :tangle "my-emacs-packages/my-emacs-evil.el"
  (use-package evil-mc
    :ensure t
    :after evil
    :hook
    evil-mode
    :general
    (:keymaps 'evil-visual-state-map
  	    ",a" 'evil-mc-make-all-cursors
  	    )
    (:keymaps 'evil-normal-state-map
  	    ",d" 'evil-mc-undo-all-cursors
  	    ",r" 'evil-mc-resume-cursors
  	    ",p" 'evil-mc-pause-cursors
  	    ",m" 'evil-mc-make-cursor-here
  	    )

    (:keymaps 'evil-insert-state-map
  	    "M-, a" 'evil-mc-make-all-cursors
  	    "M-, d" 'evil-mc-undo-all-cursors
  	    "M-, r" 'evil-mc-resume-cursors
  	    "M-, p" 'evil-mc-pause-cursors
  	    "M-, m" 'evil-mc-make-cursor-here
  	    )
  )
#+end_src

